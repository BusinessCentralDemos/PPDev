name: " Get Power Platform changes"

on:
  workflow_dispatch:
    inputs:
      solutionName:
        description: "Solution Name"
        required: true
        default: "PPSolution"
      environment:
        description: "Environment"
        required: true
        default: "QA"

permissions:
  contents: read
  actions: read
  pull-requests: write
  checks: write

defaults:
  run:
    shell: powershell

env:
  workflowDepth: 1
  ALGoOrgSettings: ${{ vars.ALGoOrgSettings }}
  ALGoRepoSettings: ${{ vars.ALGoRepoSettings }}

jobs:
  Initialization:
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    runs-on: [windows-latest]
    outputs:
      telemetryScopeJson: ${{ steps.init.outputs.telemetryScopeJson }}
      settings: ${{ steps.ReadSettings.outputs.SettingsJson }}
      projects: ${{ steps.ReadSettings.outputs.ProjectsJson }}
      projectCount: ${{ steps.ReadSettings.outputs.ProjectCount }}
      environments: ${{ steps.ReadSettings.outputs.EnvironmentsJson }}
      environmentCount: ${{ steps.ReadSettings.outputs.EnvironmentCount }}
      deliveryTargets: ${{ steps.DetermineDeliveryTargets.outputs.DeliveryTargetsJson }}
      deliveryTargetCount: ${{ steps.DetermineDeliveryTargets.outputs.DeliveryTargetCount }}
      githubRunner: ${{ steps.ReadSettings.outputs.GitHubRunnerJson }}
      githubRunnerShell: ${{ steps.ReadSettings.outputs.GitHubRunnerShell }}
      checkRunId: ${{ steps.CreateCheckRun.outputs.checkRunId }}
      projectDependenciesJson: ${{ steps.ReadSettings.outputs.ProjectDependenciesJson }}
      buildOrderJson: ${{ steps.ReadSettings.outputs.BuildOrderJson }}
      buildOrderDepth: ${{ steps.ReadSettings.outputs.BuildOrderDepth }}
      buildModes: ${{ steps.ReadSettings.outputs.BuildModes }}
    steps:
      - name: Create CI/CD Workflow Check Run
        id: CreateCheckRun
        if: github.event_name == 'workflow_run'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            var details_url = context.serverUrl.concat('/',context.repo.owner,'/',context.repo.repo,'/actions/runs/',context.runId)
            var response = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'CI/CD Workflow',
              head_sha: '${{ github.event.workflow_run.head_sha }}',
              status: 'queued',
              details_url: details_url,
              output: {
                title: 'CI/CD Workflow',
                summary: '[Workflow Details]('.concat(details_url,')')
              }
            });
            core.setOutput('checkRunId', response.data.id);

      - name: Checkout
        uses: actions/checkout@v3
        with:
          lfs: true

      - name: Download Pull Request Changes
        if: github.event_name == 'workflow_run'
        uses: actions/github-script@v6
        with:
          script: |
            var run_id = Number('${{ github.event.workflow_run.id }}');
            var artifacts = await github.rest.actions.listWorkflowRunArtifacts({
               owner: context.repo.owner,
               repo: context.repo.repo,
               run_id: run_id
            });
            var matchArtifact = artifacts.data.artifacts.filter((artifact) => {
              return artifact.name == 'Pull_Request_Files'
            })[0];
            var download = await github.rest.actions.downloadArtifact({
               owner: context.repo.owner,
               repo: context.repo.repo,
               artifact_id: matchArtifact.id,
               archive_format: 'zip'
            });
            var fs = require('fs');
            fs.writeFileSync('.PullRequestChanges.zip', Buffer.from(download.data));

      - name: Apply Pull Request Changes
        if: github.event_name == 'workflow_run'
        env:
          PRREPOFULLNAME: ${{ github.event.workflow_run.head_repository.full_name }}
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $location = (Get-Location).path
          $prfolder = '.PullRequestChanges'
          Expand-Archive -Path (Join-Path "." "$prfolder.zip") -DestinationPath (Join-Path "." $prfolder)
          Remove-Item -Path (Join-Path "." "$prfolder.zip") -force
          Get-ChildItem -Path $prfolder -Recurse -File | ForEach-Object {
            $path = $_.FullName
            $deleteFile = $path.EndsWith('.REMOVE')
            if ($deleteFile) {
              $path = $path.SubString(0,$path.Length-7)
            }
            $newPath = $path.Replace("$prfolder$([System.IO.Path]::DirectorySeparatorChar)","")
            $newFolder = [System.IO.Path]::GetDirectoryName($newPath)
            $extension = [System.IO.Path]::GetExtension($path)
            $filename = [System.IO.Path]::GetFileName($path)
            if ($ENV:PRREPOFULLNAME -ne $ENV:GITHUB_REPOSITORY) {
              if ($extension -eq '.ps1' -or $extension -eq '.yaml' -or $extension -eq '.yml' -or $filename -eq "CODEOWNERS") {
                throw "Pull Request containing changes to scripts, workflows or CODEOWNERS are not allowed from forks."
              }
            }
            if ($deleteFile) {
              if (Test-Path $newPath) {
                Write-Host "Removing $newPath"
                Remove-Item $newPath -Force
              }
              else {
                Write-Host "$newPath was already deleted"
              }
            }
            else {
              if (-not (Test-Path $newFolder)) {
                New-Item $newFolder -ItemType Directory | Out-Null
              }
              Write-Host "Copying $path to $newFolder"
              Copy-Item $path -Destination $newFolder -Force
            }
          }
          Remove-Item -Path $prfolder -recurse -force

      - name: Initialize the workflow
        id: init
        uses: BusinessCentralDemos/AL-Go-Actions/WorkflowInitialize@PowerPlatform
        with:
          shell: powershell
          eventId: "DO0091"

      - name: Read settings
        id: ReadSettings
        uses: BusinessCentralDemos/AL-Go-Actions/ReadSettings@PowerPlatform
        with:
          shell: powershell
          parentTelemetryScopeJson: ${{ steps.init.outputs.telemetryScopeJson }}
          getProjects: "Y"
          getEnvironments: "*"

      - name: Determine Delivery Target Secrets
        id: DetermineDeliveryTargetSecrets
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $deliveryTargetSecrets = @('GitHubPackagesContext','NuGetContext','StorageContext','AppSourceContext')
          $namePrefix = 'DeliverTo'
          Get-Item -Path (Join-Path $ENV:GITHUB_WORKSPACE ".github/$($namePrefix)*.ps1") | ForEach-Object {
            $deliveryTarget = [System.IO.Path]::GetFileNameWithoutExtension($_.Name.SubString($namePrefix.Length))
            $deliveryTargetSecrets += @("$($deliveryTarget)Context")
          }
          Add-Content -Path $env:GITHUB_OUTPUT -Value "Secrets=$($deliveryTargetSecrets -join ',')"

      - name: Read secrets
        uses: BusinessCentralDemos/AL-Go-Actions/ReadSecrets@PowerPlatform
        env:
          secrets: ${{ toJson(secrets) }}
        with:
          shell: powershell
          settingsJson: ${{ env.Settings }}
          secrets: ${{ steps.DetermineDeliveryTargetSecrets.outputs.Secrets }}

      - name: Determine Delivery Targets
        id: DetermineDeliveryTargets
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $deliveryTargets = @('GitHubPackages','NuGet','Storage')
          if ($env:type -eq "AppSource App") {
            $continuousDelivery = $false
            # For multi-project repositories, we will add deliveryTarget AppSource if any project has AppSourceContinuousDelivery set to true
            ('${{ steps.ReadSettings.outputs.ProjectsJson }}' | ConvertFrom-Json) | where-Object { $_ } | ForEach-Object {
              $projectSettings = Get-Content (Join-Path $_ '.AL-Go/settings.json') -raw | ConvertFrom-Json
              if ($projectSettings.PSObject.Properties.Name -eq 'AppSourceContinuousDelivery' -and $projectSettings.AppSourceContinuousDelivery) {
                Write-Host "Project $_ is setup for Continuous Delivery"
                $continuousDelivery = $true
              }
            }
            if ($continuousDelivery) {
              $deliveryTargets += @("AppSource")
            }
          }
          $namePrefix = 'DeliverTo'
          Get-Item -Path (Join-Path $ENV:GITHUB_WORKSPACE ".github/$($namePrefix)*.ps1") | ForEach-Object {
            $deliveryTarget = [System.IO.Path]::GetFileNameWithoutExtension($_.Name.SubString($namePrefix.Length))
            $deliveryTargets += @($deliveryTarget)
          }
          $deliveryTargets = @($deliveryTargets | Select-Object -unique | Where-Object {
            $include = $false
            Write-Host "Check DeliveryTarget $_"
            $contextName = "$($_)Context"
            $deliveryContext = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String([System.Environment]::GetEnvironmentVariable($contextName)))
            if ($deliveryContext) {
              $settingName = "DeliverTo$_"
              $settings = $env:Settings | ConvertFrom-Json
              if (($settings.PSObject.Properties.Name -eq $settingName) -and ($settings."$settingName".PSObject.Properties.Name -eq "Branches")) {
                Write-Host "Branches:"
                $settings."$settingName".Branches | ForEach-Object {
                  Write-Host "- $_"
                  if ($ENV:GITHUB_REF_NAME -like $_) {
                    $include = $true
                  }
                }
              }
              else {
                $include = ($ENV:GITHUB_REF_NAME -eq 'main')
              }
            }
            if ($include) {
              Write-Host "DeliveryTarget $_ included"
            }
            $include
          })
          $deliveryTargetsJson = $deliveryTargets | ConvertTo-Json -Depth 99 -compress
          if ($deliveryTargets.Count -lt 2) { $deliveryTargetsJson = "[$($deliveryTargetsJson)]" }
          Add-Content -Path $env:GITHUB_OUTPUT -Value "DeliveryTargetsJson=$deliveryTargetsJson"
          Write-Host "DeliveryTargetsJson=$deliveryTargetsJson"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "DeliveryTargetCount=$($deliveryTargets.Count)"
          Write-Host "DeliveryTargetCount=$($deliveryTargets.Count)"
          Add-Content -Path $env:GITHUB_ENV -Value "DeliveryTargets=$deliveryTargetsJson"

      - name: Determine Build Order
        if: env.workflowDepth > 1
        id: BuildOrder
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $projects = '${{ steps.ReadSettings.outputs.ProjectsJson }}' | ConvertFrom-Json
          $buildOrder = '${{ steps.ReadSettings.outputs.BuildOrderJson }}' | ConvertFrom-Json
          $depth = ${{ steps.ReadSettings.outputs.BuildOrderDepth }}
          $workflowDepth = ${{ env.workflowDepth }}
          if ($depth -lt $workflowDepth) {
            Write-Host "::Error::Project Dependencies depth is $depth. Workflow is only setup for $workflowDepth. You need to Run Update AL-Go System Files to update the workflows"
            $host.SetShouldExit(1)
          }
          $step = $depth
          $depth..1 | ForEach-Object {
            $ps = @($buildOrder."$_" | Where-Object { $projects -contains $_ })
            if ($ps.Count -eq 1) {
              $projectsJSon = "[$($ps | ConvertTo-Json -compress)]"
            }
            else {
              $projectsJSon = $ps | ConvertTo-Json -compress
            }
            if ($ps.Count -gt 0) {
              Add-Content -Path $env:GITHUB_OUTPUT -Value "projects$($step)Json=$projectsJson"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "projects$($step)Count=$($ps.count)"
              Write-Host "projects$($step)Json=$projectsJson"
              Write-Host "projects$($step)Count=$($ps.count)"
              $step--
            }
          }
          while ($step -ge 1) {
              Add-Content -Path $env:GITHUB_OUTPUT -Value "projects$($step)Json="
              Add-Content -Path $env:GITHUB_OUTPUT -Value "projects$($step)Count=0"
              Write-Host "projects$($step)Json="
              Write-Host "projects$($step)Count=0"
              $step--
          }

  PullChanges:
    needs: [Initialization]
    if: needs.Initialization.outputs.environmentCount > 0
    runs-on: [windows-latest]
    name: Deploy to ${{ inputs.environment }}
    environment:
      name: ${{ inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: EnvName
        id: envName
        shell: powershell
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $envName = '${{ inputs.environment }}'
          Add-Content -Path $env:GITHUB_OUTPUT -Value "envName=$envName"

      - name: Read settings
        uses: BusinessCentralDemos/AL-Go-Actions/ReadSettings@PowerPlatform
        with:
          shell: powershell

      - name: Read secrets
        uses: BusinessCentralDemos/AL-Go-Actions/ReadSecrets@PowerPlatform
        env:
          secrets: ${{ toJson(secrets) }}
        with:
          shell: powershell
          settingsJson: ${{ env.Settings }}
          secrets: "${{ steps.envName.outputs.envName }}-AuthContext,${{ steps.envName.outputs.envName }}_AuthContext,AuthContext,${{ steps.envName.outputs.envName }}-EnvironmentName,${{ steps.envName.outputs.envName }}_EnvironmentName,EnvironmentName,projects"

      - name: AuthContext
        id: authContext
        shell: powershell
        run: |
          $ErrorActionPreference = "STOP"
          Set-StrictMode -version 2.0
          $envName = '${{ steps.envName.outputs.envName }}'
          $deployToSettingStr = [System.Environment]::GetEnvironmentVariable("DeployTo$envName")
          if ($deployToSettingStr) {
            $deployToSettings = $deployToSettingStr | ConvertFrom-Json
          }
          else {
            $deployToSettings = [PSCustomObject]@{}
          }
          $authContext = $null
          "$($envName)-AuthContext", "$($envName)_AuthContext", "AuthContext" | ForEach-Object {
            if (!($authContext)) {
              $authContext = [System.Environment]::GetEnvironmentVariable($_)
              if ($authContext) {
                Write-Host "Using $_ secret as AuthContext"
              }
            }            
          }
          if (!($authContext)) {
            Write-Host "::Error::No AuthContext provided"
            exit 1
          }
          if (("$deployToSettings" -ne "") -and $deployToSettings.PSObject.Properties.name -eq "EnvironmentName") {
            $environmentName = $deployToSettings.environmentName
          }
          else {
            $environmentName = $null
            "$($envName)-EnvironmentName", "$($envName)_EnvironmentName", "EnvironmentName" | ForEach-Object {
              if (!($EnvironmentName)) {
                $EnvironmentName = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String([System.Environment]::GetEnvironmentVariable($_)))
                if ($EnvironmentName) {
                  Write-Host "Using $_ secret as EnvironmentName"
                  Write-Host "Please consider using the DeployTo$_ setting instead, where you can specify EnvironmentName, projects and branches"
                }
              }            
            }
            if (!($environmentName)) {
              $environmentName = '${{ steps.envName.outputs.envName }}'
            }
            $deployToSettings | Add-Member -MemberType NoteProperty -name 'environmentName' -value $environmentName
          }
          $environmentName = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(($environmentName + '${{ inputs.environment }}'.SubString($envName.Length)).ToUpperInvariant()))
          if (("$deployToSettings" -ne "") -and $deployToSettings.PSObject.Properties.name -eq "projects") {
            $projects = $deployToSettings.projects
          }
          else {
            $projects = [System.Environment]::GetEnvironmentVariable("$($envName)-projects")
            if (-not $projects) {
              $projects = [System.Environment]::GetEnvironmentVariable("$($envName)_Projects")
              if (-not $projects) {
                $projects = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String([System.Environment]::GetEnvironmentVariable('projects')))
              }
            }
            $deployToSettings | Add-Member -MemberType NoteProperty -Name 'projects' -Value $projects
          }
          $powerPlatformSolutionFolder = [System.Environment]::GetEnvironmentVariable('PowerPlatformSolutionFolder')
          $deployPP = $false
          if ($projects -eq '' -or $projects -eq '*') {
            $projects = '*'
            $deployPP = ("$powerPlatformSolutionFolder" -ne "")
          }
          else {
            $buildProjects = '${{ needs.Initialization.outputs.projects }}' | ConvertFrom-Json
            $projects = ($projects.Split(',') | Where-Object { 
              $deployALProject = $buildProjects -contains $_
              if ($_ -eq $powerPlatformSolutionFolder) {
                $deployPP = $true
                $deployALProject = $false
              }
              $deployALProject
            }) -join ','
          }

          Add-Content -Path $env:GITHUB_OUTPUT -Value "authContext=$authContext"
          Write-Host "authContext=$authContext"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "deployToSettings=$($deployToSettings | ConvertTo-Json -depth 99 -compress)"
          Write-Host "deployToSettings=$deployToSettings"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "environmentName=$environmentName"
          Write-Host "environmentName=$([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($environmentName)))"
          Write-Host "environmentName (as Base64)=$environmentName"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "projects=$projects"
          Write-Host "projects=$projects"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "deployPP=$deployPP"
          Write-Host "deployPP=$deployPP"

      - name: test input
        shell: powershell
        run: |
          Write-Host "Deploy settings: ${{ steps.AuthContext.outputs.deployToSettings }}";
          Write-Host "Auth settings: ${{ steps.AuthContext.outputs.authContext }}";

      - name: Parse deployTo JSON
        shell: powershell
        run: |
          $json = '${{ steps.AuthContext.outputs.deployToSettings }}'
          $obj = ConvertFrom-Json $json
          Write-Output $obj.environmentName
          $environmentName = $obj.environmentName;
          echo "environmentName=$environmentName" >> $env:GITHUB_ENV
          Write-Output $obj.'environment-url'
          $environmentUrl = $obj.'environment-url';
          echo "environmentUrl=$environmentUrl" >> $env:GITHUB_ENV
          Write-Output $obj.bcEnvironment
          $bcEnvironment = $obj.bcEnvironment;
          echo "bcEnvironment=$bcEnvironment" >> $env:GITHUB_ENV
          write-output $obj.bcCompanyId
          $bcCompanyId = $obj.bcCompanyId;
          echo "bcCompanyId=$bcCompanyId" >> $env:GITHUB_ENV
